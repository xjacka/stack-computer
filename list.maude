load instrukce.maude

fth TRIV is
 sort Elt .
endfth

fmod SEQUENCE{X :: TRIV} is
	sorts NeSequence{X} Sequence{X} .
    subsort NeSequence{X} < Sequence{X} .
    subsort X$Elt < NeSequence{X}.

	op EOP : -> Sequence{X} [ctor] .
	op _;_ : X$Elt Sequence{X} -> NeSequence{X} [ctor prec 4 id: EOP] .

	var A : X$Elt .
	var B : Sequence{X} .

	op get_ : NeSequence{X} -> X$Elt .
	eq get(A ; B) = A .

    op del : NeSequence{X} -> Sequence{X} .
    eq del(A ; B) = B .
endfm

fmod ELEM is
	pr INSTRUCTION .
	pr INT .

	sort Elem .

	var Ins : Instruction .
	op _:_ : Int Instruction -> Elem [ctor prec 3] .
endfm

view Instruction from TRIV to ELEM is
    sort Elt to Elem .
endv

fmod INPUT-SEQUENCE is
	pr SEQUENCE{Nat} .
endfm

fmod INSTRUCTION-SEQUENCE is
	pr SEQUENCE{Instruction} .

	var A : Instruction .
	var El : Int .
	var Lb : Int .
	var B : Sequence{Instruction} .

	op after(_,_) : Int Sequence{Instruction} -> Sequence{Instruction} .
	eq after(El, (Lb : A) ; B) = if El == Lb then (Lb : A) ; B else after(El, B) fi .
endfm

fmod OUTPUT-SEQUENCE is
	pr SEQUENCE{Nat} .
endfm

*** red in INSTRUCTION-SEQUENCE : get (RD ; RD ; RD ; AD ; AD ; WR ; EOP) .