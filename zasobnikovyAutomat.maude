load zasobnik.maude
load pamet.maude
load list.maude
load sequence.maude
load instrukce.maude

fmod AUTOMAT-STATE is

	pr MEMORY .
	pr OP-STACK .
	pr INSTRUCTION-SEQUENCE .
	pr INPUT-LIST .
	pr OUTPUT-LIST .
	pr INSTRUCTION .

	sorts AutomatState .

	op create(_,_,_,_,_) : Sequence{Instruction} List{Nat} List{Nat} Stack{Nat} Map{Nat, Int}
		-> AutomatState [ctor prec 122] .

    var S : Sequence{Instruction} .
	var I : List{Nat} .
    var O : List{Nat} .
    var ST : Stack{Nat} .
    var MEM : Map{Nat, Int} .
	var Ins : Instruction .
	var Inp : Nat .
	vars a b : Nat .
	var addr : Int .
	var Lb : Int .

	op next(_) : AutomatState -> AutomatState .
	eq next(create(EOP, I, O, ST, MEM)) = create(EOP, I, O, ST, MEM) .

	eq next(create(Lb : RD ; S, Inp I, O, ST, MEM)) = next(create(S, I, O, push(value(Inp), ST), MEM)) .
	eq next(create(Lb : WR ; S, I, O, push(value(a), ST), MEM)) = next(create(S, I, O a, ST, MEM)) .

	eq next(create(Lb : AD ; S, I, O, push(value(a), push(value(b), ST)), MEM)) = next(create(S, I, O, push(value(a + b), ST), MEM)) .
	eq next(create(Lb : SB ; S, I, O, push(value(a), push(value(b), ST)), MEM)) = next(create(S, I, O, push(value(a - b), ST), MEM)) .
	eq next(create(Lb : MT ; S, I, O, push(value(a), push(value(b), ST)), MEM)) = next(create(S, I, O, push(value(a * b), ST), MEM)) .
	eq next(create(Lb : DI ; S, I, O, push(value(a), push(value(b), ST)), MEM)) = next(create(S, I, O, push(value(a * b), ST), MEM)) . *** TODO

	eq next(create(Lb : ST ; S, I, O, push(a, push(b, ST)), MEM)) = next(create(S, I, O, ST, insert(a, b, MEM))) .
	eq next(create(Lb : DR ; S, I, O, push(address(a), ST), (a |-> b ,MEM))) = next(create(S, I, O, push(value(b), ST), MEM)) .

	eq next(create(Lb : TA addr ; S, I, O, ST, MEM)) = next(create(S, I, O, push(address(addr), ST), MEM)) .
	eq next(create(Lb : TV addr ; S, I, O, ST, MEM)) = next(create(S, I, O, push(value(addr), ST), MEM)) .

	eq next(create(Lb : JU addr ; S, I, O, ST, MEM)) = next(create(after(addr, S), I, O, ST, MEM)) .
	eq next(create(Lb : JZ addr ; S, I, O, push(value(a), ST), MEM)) = if a == 0
		then next(create(after(addr, S), I, O, ST, MEM))
		else next(create(S, I, O, ST, MEM)) fi .

	op output(_) : AutomatState -> List{Nat} .
	eq output(create(S, I, O, ST, MEM)) = O .

endfm

fmod AUTOMAT is
	pr AUTOMAT-STATE .

	op run : Sequence{Instruction} List{Nat} -> List{Nat} .
	op run-internal(_) : AutomatState -> AutomatState .

	var S : Sequence{Instruction} .
	var I : List{Nat} .
	var O : List{Nat} .
	var ST : Stack{Nat} .
	var MEM : Map{Nat, Int} .

	eq run(S, I) = output(run-internal(create(S, I, EOP, empty, empty))) .
	eq run-internal(create(S, I, O, ST, MEM)) = next(create(S, I, O, ST, MEM)) .

	op debug : Sequence{Instruction} List{Nat} -> AutomatState .
	eq debug(S, I) = run-internal(create(S, I, EOP, empty, empty)) .
endfm

*** red in AUTOMAT : run(RD ; RD ; RD ; AD ; AD ; WR ; EOP , 10 20 30) .